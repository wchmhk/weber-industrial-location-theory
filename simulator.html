<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>韋伯工業區位理論模擬器 - 多原料版 (即時計算)</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --primary-color-dark: #4a49b0;
            --background-color: #f8f9fa;
            --card-color: #ffffff;
            --text-color: #333333;
            --secondary-text: #666666;
            --border-color: #ddd;
            --labor-color: rgba(255, 180, 0, 0.8);
            --labor-bg: rgba(255, 240, 200, 0.3);
            --agglom-color: rgba(0, 120, 255, 0.8);
            --agglom-bg: rgba(200, 240, 255, 0.3);
            --material-border: #999;
        }

        .dark {
            --primary-color: #7b7aef;
            --primary-color-dark: #6665d9;
            --background-color: #181818;
            --card-color: #292929;
            --text-color: #e0e0e0;
            --secondary-text: #b0b0b0;
            --border-color: #444;
            --labor-color: rgba(255, 180, 0, 0.9);
            --labor-bg: rgba(255, 180, 0, 0.15);
            --agglom-color: rgba(70, 150, 255, 0.9);
            --agglom-bg: rgba(70, 150, 255, 0.15);
            --material-border: #666;
        }

        html, body {
            font-family: 'Microsoft YaHei', '微軟正黑體', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            height: 100%;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }

        .title-container {
            flex: 0 0 auto;
            margin-bottom: 10px;
        }

        h1, h2, h3, h4 {
            color: var(--text-color);
            margin-top: 0;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .left-column {
            grid-column: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .map-section, .control-section, .results-section {
            background: var(--card-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .scrollable-content {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--background-color);
        }

        .scrollable-content::-webkit-scrollbar {
            width: 8px;
        }

        .scrollable-content::-webkit-scrollbar-track {
            background: var(--background-color);
            border-radius: 4px;
        }

        .scrollable-content::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 4px;
        }

        .results-section {
            grid-column: 2;
            grid-row: 1 / span 2;
        }

        #canvas-container {
            width: 100%;
            height: 300px;
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        canvas {
            display: block;
            background-color: var(--card-color);
            transition: background-color 0.3s ease;
        }

        .controls {
            margin-top: 15px;
        }

        .parameters-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 15px;
            align-items: center;
        }

        .full-width {
            grid-column: 1 / span 2;
        }

        .slider-container {
            display: flex;
            align-items: center;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            font-size: 14px;
            color: var(--text-color);
            transition: color 0.3s ease;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            accent-color: var(--primary-color);
        }

        .slider-value {
            font-size: 14px;
            color: var(--secondary-text);
            transition: color 0.3s ease;
            min-width: 40px;
            text-align: right;
        }

        select {
            width: 100%;
            margin-bottom: 5px;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--card-color);
            color: var(--text-color);
            font-size: 14px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--primary-color-dark);
        }

        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        .results {
            padding: 10px;
            background-color: var(--background-color);
            border-radius: 4px;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        /* 新增：原料管理樣式 */
        #material-manager {
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            grid-column: 1 / span 2;
            background-color: var(--background-color);
        }

        .material-item {
            display: grid;
            grid-template-columns: 50px 1fr auto;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
            padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .material-item:last-child {
            border-bottom: none;
        }

        .material-label {
            font-weight: bold;
            color: var(--text-color);
        }
        .remove-material-btn {
            background-color: #e74c3c;
            padding: 4px 8px;
            font-size: 12px;
        }
        .remove-material-btn:hover {
            background-color: #c0392b;
        }
        .add-material-btn {
            width: 100%;
            margin-top: 10px;
            padding: 6px;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            .left-column, .results-section {
                grid-column: 1;
            }
            .results-section {
                grid-row: auto;
            }
            .controls {
                grid-template-columns: 1fr;
            }
            .button-group {
                justify-content: center;
            }
        }

        #debug-info {
            margin-top: 10px;
            padding: 8px;
            background-color: var(--background-color);
            border-radius: 4px;
            font-size: 12px;
            display: none;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .labor-control {
            border-left: 4px solid var(--labor-color);
            padding-left: 8px;
        }

        .agglom-control {
            border-left: 4px solid var(--agglom-color);
            padding-left: 8px;
        }

        /* Resizer styles (unchanged) */
        .resizer {
            position: relative;
            background-color: var(--background-color);
            transition: background-color 0.3s ease;
        }
        .resizer:hover {
            background-color: var(--primary-color);
        }
        .horizontal-resizer {
            height: 8px;
            cursor: ns-resize;
            margin: -4px 0;
            z-index: 5;
        }
        .vertical-resizer {
            width: 8px;
            cursor: ew-resize;
            margin: 0 -4px;
            z-index: 5;
        }
        .resizer-handle {
            position: absolute;
            background-color: var(--primary-color);
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        .horizontal-resizer .resizer-handle {
            height: 2px;
            width: 40px;
            top: 3px;
            left: calc(50% - 20px);
        }
        .vertical-resizer .resizer-handle {
            width: 2px;
            height: 40px;
            left: 3px;
            top: calc(50% - 20px);
        }
        .resizer:hover .resizer-handle {
            opacity: 1;
        }
        .resizer, .resizer-handle {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="title-container">
            <h1>韋伯工業區位理論互動模擬器 (多原料版 / 即時計算)</h1>
        </div>
        <div class="container" id="main-container" style="grid-template-columns: 67% 33%; flex: 1; overflow: hidden;">
        <div class="left-column" id="left-column">
            <div class="map-section" id="map-section" style="height: 38%">
                <div id="canvas-container">
                    <canvas id="weberCanvas" width="550" height="400"></canvas>
                </div>
            </div>

            <!-- 水平分隔線 -->
            <div class="resizer horizontal-resizer" id="map-control-resizer">
                <div class="resizer-handle"></div>
            </div>

            <div class="control-section" id="control-section">
                <div class="scrollable-content">
                    <div class="controls">

                        <div id="material-manager" class="full-width">
                            <label><strong>原料產地設定 (拖曳地圖上的點修改位置)</strong></label>
                            <div id="material-list-container">
                                <!-- Dynamic material inputs will be injected here -->
                            </div>
                            <button id="add-material-btn" class="add-material-btn">新增原料產地</button>
                        </div>

                        <div class="parameters-grid">

                            <label for="weight-loss">重量損失率 (%)</label>
                            <div class="slider-container">
                                <input type="range" id="weight-loss" min="0" max="90" value="30" step="5">
                                <span id="weight-loss-value" class="slider-value">30%</span>
                            </div>

                            <label for="transport-cost">運輸成本 (每公里/噸)</label>
                            <div class="slider-container">
                                <input type="range" id="transport-cost" min="1" max="10" value="5" step="0.5">
                                <span id="transport-cost-value" class="slider-value">5.0</span>
                            </div>

                            <!-- 勞動力因素 -->
                            <h3 class="full-width" style="margin-top:10px;">勞動力與聚集因素</h3>

                            <label for="labor-cost-weight">勞動力成本權重</label>
                            <div class="slider-container">
                                <input type="range" id="labor-cost-weight" min="0" max="1" value="0.3" step="0.1">
                                <span id="labor-cost-weight-value" class="slider-value">0.3</span>
                            </div>

                            <label for="labor-savings" class="labor-label">勞動力優勢區</label>
                            <div class="slider-container">
                                <select id="labor-savings">
                                    <option value="none">無勞動力優勢區</option>
                                    <option value="light">輕微 (10% 節省)</option>
                                    <option value="moderate">中等 (20% 節省)</option>
                                    <option value="significant">顯著 (30% 節省)</option>
                                    <option value="dominant">主導 (40% 節省)</option>
                                </select>
                            </div>

                            <div id="labor-intensity-container" class="full-width" style="display:none;">
                                <label for="labor-intensity">勞動力密集程度</label>
                                <div class="slider-container">
                                    <input type="range" id="labor-intensity" min="0" max="100" value="50" step="10">
                                    <span id="labor-intensity-value" class="slider-value">50%</span>
                                </div>
                            </div>

                            <label for="agglomeration" class="agglom-label">聚集經濟效應</label>
                            <div class="slider-container">
                                <select id="agglomeration">
                                    <option value="none">無聚集效應</option>
                                    <option value="light">輕微 (5% 節省)</option>
                                    <option value="moderate">中等 (15% 節省)</option>
                                    <option value="significant">顯著 (25% 節省)</option>
                                </select>
                            </div>

                            <div id="specialization-container" class="full-width" style="display:none;">
                                <label for="industry-specialization">產業專業化程度</label>
                                <div class="slider-container">
                                    <input type="range" id="industry-specialization" min="0" max="100" value="50" step="10">
                                    <span id="industry-specialization-value" class="slider-value">50%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="button-group">
                    <button id="step-back-btn" disabled>上一步 (Ctrl/Cmd+Z)</button>
                    <button id="reset-btn">重置模擬</button>
                    <button id="toggle-debug" style="background-color:#888">顯示調試信息</button>
                    <button id="show-theory-btn">顯示韋伯理論說明</button>
                </div>

                <div id="debug-info"></div>
            </div>
        </div>

        <!-- 垂直分隔線 -->
        <div class="resizer vertical-resizer" id="column-resizer">
            <div class="resizer-handle"></div>
        </div>

        <div class="results-section" id="results-section">
            <h2>分析結果</h2>
            <div class="scrollable-content">

            <div id="theory-explanation" style="display:none;" class="info-panel">
                <h3>韋伯工業區位理論 (Weber's Industrial Location Theory)</h3>
                <p>阿爾弗雷德·韋伯(Alfred Weber)於1909年提出的理論，旨在尋找總成本最低的工廠區位，主要考慮三個因素：</p>
                <ol>
                    <li><strong>運輸成本 (主導因素)</strong>：原料運費 + 製成品運費。區位點由原料和製成品重量的權重決定。</li>
                    <li><strong>勞動力成本偏離</strong>：如果某地勞動力成本節省額度，大於因此增加的運輸成本，則工廠會偏離運輸成本最低點。</li>
                    <li><strong>聚集經濟偏離</strong>：如果聚集帶來的間接成本節省，大於因此增加的運輸成本，則工廠會偏離。</li>
                </ol>
                <p>此模擬器使用韋伯多角形模型計算運輸成本最低點，並通過成本比較來判斷勞動力和聚集效應是否會導致區位偏離。</p>
            </div>

            <div id="loading-indicator" class="loading-indicator" style="display:none;">
                正在計算最佳區位...
            </div>

            <div class="results">
                <div id="optimal-location">
                    <p>調整參數或拖曳地圖上的點，結果將即時更新。</p>
                </div>
                <div id="cost-breakdown"></div>

                <div id="labor-analysis" class="labor-control" style="display:none;">
                    <h4>勞動力影響分析</h4>
                    <div id="labor-impact-detail"></div>
                </div>

                <div id="agglom-analysis" class="agglom-control" style="display:none;">
                    <h4>聚集效應影響分析</h4>
                    <div id="agglom-impact-detail"></div>
                </div>

                <div id="factor-comparison" style="margin-top:15px;"></div>
            </div>
            </div>
        </div>
    </div>

    <script>
        // 檢測暗黑模式偏好
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        const canvas = document.getElementById('weberCanvas');
        const ctx = canvas.getContext('2d');
        const STEP_BACK_BTN = document.getElementById('step-back-btn');

        // --- 核心數據結構 ---
        let materials = [];
        let market = { x: 275, y: 400, label: '市場', color: '#3498db', weight: 1 };
        let optimal = { x: 0, y: 0, label: 'O', color: '#9b59b6' };

        let weightLoss = 30;
        let transportCost = 5;
        let laborSavings = 'none';
        let laborIntensity = 50;
        let laborCostWeight = 0.3;
        let agglomeration = 'none';
        let industrySpecialization = 50;

        let laborZone = { x: 150, y: 200, radius: 0 };
        let agglomerationZone = { x: 450, y: 220, radius: 0 };

        const GRID_SIZE = 50;
        let isDragging = false;
        let selectedPoint = null;
        let debugMode = false;

        // --- 歷史記錄機制 ---
        const MAX_HISTORY = 20;
        let historyStack = [];
        let lastCalculationState = null;

        // 存儲當前狀態
        function saveCurrentState() {
            // 在儲存前，確保將當前參數值從 UI 讀入全局變量，避免歷史記錄中參數不同步
            updateGlobalParamsFromUI();

            const currentState = {
                materials: materials.map(m => ({ ...m })), // 深拷貝
                market: { ...market },
                optimal: { ...optimal },
                params: {
                    weightLoss, transportCost, laborCostWeight, laborSavings, laborIntensity, agglomeration, industrySpecialization
                },
                zones: {
                    laborZone: { ...laborZone },
                    agglomerationZone: { ...agglomerationZone }
                }
            };

            // 避免連續儲存重複狀態
            const currentStateJSON = JSON.stringify(currentState);
            if (lastCalculationState === currentStateJSON) return;

            if (historyStack.length >= MAX_HISTORY) {
                historyStack.shift(); // 移除最舊的狀態
            }
            historyStack.push(currentState);
            lastCalculationState = currentStateJSON;

            STEP_BACK_BTN.disabled = historyStack.length <= 1;
        }

        // 恢復上一步狀態
        function restorePreviousState() {
            if (historyStack.length <= 1) return;

            // 移除當前狀態 (即將回退到的狀態之前的一個)
            historyStack.pop();

            const prevState = historyStack[historyStack.length - 1];

            // 恢復參數
            weightLoss = prevState.params.weightLoss;
            transportCost = prevState.params.transportCost;
            laborCostWeight = prevState.params.laborCostWeight;
            laborSavings = prevState.params.laborSavings;
            laborIntensity = prevState.params.laborIntensity;
            agglomeration = prevState.params.agglomeration;
            industrySpecialization = prevState.params.industrySpecialization;

            // 恢復點位和區域
            materials = prevState.materials.map(m => ({ ...m })); // 確保深拷貝
            market = { ...prevState.market };
            optimal = { ...prevState.optimal };
            laborZone = { ...prevState.zones.laborZone };
            agglomerationZone = { ...prevState.zones.agglomerationZone };

            // 更新 UI 顯示 (滑塊/下拉菜單/原料列表)
            updateUIFromState();

            // 由於歷史記錄的最後一個狀態已恢復，需要重新檢查按鈕狀態
            STEP_BACK_BTN.disabled = historyStack.length <= 1;

            // 重新繪製和展示結果 (不需要重新執行複雜計算，因為結果已經儲存在 optimal 中)
            calculateAndRenderResults(false);
        }

        // 根據歷史狀態恢復 UI 控件顯示
        function updateUIFromState() {
            // 1. 更新參數滑塊/Select
            document.getElementById('weight-loss').value = weightLoss;
            document.getElementById('weight-loss-value').textContent = weightLoss + '%';
            document.getElementById('transport-cost').value = transportCost;
            document.getElementById('transport-cost-value').textContent = transportCost.toFixed(1);
            document.getElementById('labor-cost-weight').value = laborCostWeight;
            document.getElementById('labor-cost-weight-value').textContent = laborCostWeight.toFixed(1);
            document.getElementById('labor-savings').value = laborSavings;
            document.getElementById('labor-intensity-container').style.display = laborSavings === 'none' ? 'none' : 'block';
            document.getElementById('labor-intensity').value = laborIntensity;
            document.getElementById('labor-intensity-value').textContent = laborIntensity + '%';
            document.getElementById('agglomeration').value = agglomeration;
            document.getElementById('specialization-container').style.display = agglomeration === 'none' ? 'none' : 'block';
            document.getElementById('industry-specialization').value = industrySpecialization;
            document.getElementById('industry-specialization-value').textContent = industrySpecialization + '%';

            // 2. 更新原料列表
            renderMaterialList();

            // 3. 繪製
            drawCanvas();
        }

        // 從 UI 讀取當前參數到全局變量（用於歷史記錄儲存或計算開始前）
        function updateGlobalParamsFromUI() {
            weightLoss = parseInt(document.getElementById('weight-loss').value);
            transportCost = parseFloat(document.getElementById('transport-cost').value);
            laborCostWeight = parseFloat(document.getElementById('labor-cost-weight').value);
            laborSavings = document.getElementById('labor-savings').value;
            laborIntensity = parseInt(document.getElementById('labor-intensity').value);
            agglomeration = document.getElementById('agglomeration').value;
            industrySpecialization = parseInt(document.getElementById('industry-specialization').value);
        }


        // --- 輔助函數 ---
        // (保持不變)
        function getLaborSavingFactor(laborSavingsType) {
            switch(laborSavingsType) {
                case 'light': return 0.90; case 'moderate': return 0.80;
                case 'significant': return 0.70; case 'dominant': return 0.60;
                default: return 1.0;
            }
        }
        function getAgglomerationFactor(agglomerationType) {
            switch(agglomerationType) {
                case 'light': return 0.95; case 'moderate': return 0.85;
                case 'significant': return 0.75; default: return 1.0;
            }
        }
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        function isPointInCircle(point, circle) {
            return distance(point, circle) <= circle.radius;
        }

        // --- 繪圖函數 ---
        function getMaterialColor(id) {
            const colors = ['#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22', '#1abc9c'];
            const index = materials.findIndex(m => m.id === id);
            return colors[index % colors.length];
        }

        function drawCanvas() {
            // (繪製邏輯保持不變，依賴全局變量)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const isDarkMode = document.documentElement.classList.contains('dark');
            const gridColor = isDarkMode ? '#444444' : '#e0e0e0';
            const textColor = isDarkMode ? '#e0e0e0' : '#000000';

            // 繪製網格
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // 繪製區域 (勞動力/聚集)
            if (laborSavings !== 'none') {
                let radius;
                switch(laborSavings) {
                    case 'light': radius = 50; break; case 'moderate': radius = 70; break;
                    case 'significant': radius = 90; break; case 'dominant': radius = 110; break;
                    default: radius = 0;
                }
                radius = radius * (0.75 + (laborIntensity / 100) * 0.5);
                laborZone.radius = radius;

                const laborFillStyle = isDarkMode ? 'var(--labor-bg)' : 'rgba(255, 240, 200, 0.3)';
                const laborStrokeStyle = 'var(--labor-color)';

                ctx.beginPath();
                ctx.arc(laborZone.x, laborZone.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = laborFillStyle;
                ctx.fill();
                ctx.strokeStyle = laborStrokeStyle;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = '14px Arial';
                ctx.fillText('勞動力優勢區', laborZone.x - 45, laborZone.y - radius - 10);
            }

            if (agglomeration !== 'none') {
                let radius;
                switch(agglomeration) {
                    case 'light': radius = 50; break; case 'moderate': radius = 70; break;
                    case 'significant': radius = 90; break; default: radius = 0;
                }
                radius = radius * (0.75 + (industrySpecialization / 100) * 0.5);
                agglomerationZone.radius = radius;

                const agglomFillStyle = isDarkMode ? 'var(--agglom-bg)' : 'rgba(200, 240, 255, 0.3)';
                const agglomStrokeStyle = 'var(--agglom-color)';

                ctx.beginPath();
                ctx.arc(agglomerationZone.x, agglomerationZone.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = agglomFillStyle;
                ctx.fill();
                ctx.strokeStyle = agglomStrokeStyle;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = '14px Arial';
                ctx.fillText('產業聚集區', agglomerationZone.x - 40, agglomerationZone.y - radius - 10);
            }

            // 繪製韋伯多角形 (連接所有點，如果點數 >= 2)
            const allPoints = [...materials, market];
            if (allPoints.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(allPoints[0].x, allPoints[0].y);
                for (let i = 1; i < allPoints.length; i++) {
                    ctx.lineTo(allPoints[i].x, allPoints[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = isDarkMode ? '#777' : '#aaa';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // 繪製所有點 (包括市場)
            const pointsToDraw = [...materials, market];
            for (const point of pointsToDraw) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = point.color;
                ctx.fill();

                ctx.font = '16px Arial';
                ctx.fillStyle = textColor;
                ctx.fillText(point.label, point.x + 15, point.y - 5);

                ctx.font = '12px Arial';
                ctx.fillText(`${point.weight}噸`, point.x + 15, point.y + 15);
            }

            // 如果最佳點已計算，繪製連接線
            if (optimal.x || optimal.y) {
                const totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
                const productWeight = totalInputWeight * (1 - weightLoss/100);
                const totalWeight = totalInputWeight + productWeight;

                ctx.setLineDash([5, 3]);
                materials.forEach(material => {
                    ctx.beginPath();
                    ctx.moveTo(material.x, material.y);
                    ctx.lineTo(optimal.x, optimal.y);
                    ctx.strokeStyle = material.color;
                    ctx.lineWidth = 2 + (5 * material.weight / totalWeight);
                    ctx.stroke();
                });

                ctx.beginPath();
                ctx.moveTo(market.x, market.y);
                ctx.lineTo(optimal.x, optimal.y);
                ctx.strokeStyle = market.color;
                ctx.lineWidth = 2 + (5 * productWeight / totalWeight);
                ctx.stroke();

                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(optimal.x, optimal.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = optimal.color;
                ctx.fill();
                ctx.font = '16px Arial';
                ctx.fillStyle = textColor;
                ctx.fillText(optimal.label, optimal.x + 15, optimal.y - 5);
            }
        }


        // --- 動態原料管理函數 ---

        function generateUniqueId(prefix) {
            return prefix + '_' + Date.now() + Math.floor(Math.random() * 1000);
        }

        function renderMaterialList() {
            const container = document.getElementById('material-list-container');
            container.innerHTML = '';

            materials.forEach((m, index) => {
                const materialDiv = document.createElement('div');
                materialDiv.className = 'material-item';
                materialDiv.dataset.id = m.id;

                const label = String.fromCharCode(65 + index);
                m.label = label;
                m.color = getMaterialColor(m.id);

                materialDiv.innerHTML = `
                    <span class="material-label">原料 ${label}:</span>
                    <div class="slider-container">
                        <input type="range" id="weight-${m.id}" min="0.5" max="10" value="${m.weight}" step="0.1">
                        <span id="weight-value-${m.id}" class="slider-value">${m.weight.toFixed(1)}</span>
                    </div>
                    <button class="remove-material-btn" data-id="${m.id}">移除</button>
                `;
                container.appendChild(materialDiv);

                // 綁定事件：即時計算
                document.getElementById(`weight-${m.id}`).addEventListener('input', function(e) {
                    const newWeight = parseFloat(e.target.value);
                    m.weight = newWeight;
                    document.getElementById(`weight-value-${m.id}`).textContent = newWeight.toFixed(1);
                    autoCalculateAndStore();
                });
            });

            container.querySelectorAll('.remove-material-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const idToRemove = this.dataset.id;
                    materials = materials.filter(m => m.id !== idToRemove);
                    renderMaterialList();
                    autoCalculateAndStore();
                });
            });
        }

        function addMaterial() {
            const newId = generateUniqueId('M');
            const newX = 50 + Math.random() * (canvas.width - 100);
            const newY = 50 + Math.random() * (canvas.height - 100);

            materials.push({
                id: newId,
                x: newX,
                y: newY,
                label: '',
                color: '',
                weight: 5.0
            });
            renderMaterialList();
            autoCalculateAndStore();
        }

        // --- 核心計算函數 ---

        // 用於計算運輸成本和明細的子函數
        const calculateTransportCostDetails = (location) => {
            // 確保使用最新的全局變量，這點在即時計算中非常關鍵
            updateGlobalParamsFromUI();

            let totalCost = 0;
            let materialCost = 0;
            let productCost = 0;
            let materialDetails = [];

            const totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
            const productWeight = totalInputWeight * (1 - weightLoss/100);

            // 原料至工廠運費
            materials.forEach(m => {
                const dist = distance(location, m);
                // 這裡 transportCost 影響原料運費
                const cost = m.weight * dist * transportCost;
                materialCost += cost;
                materialDetails.push({ label: m.label, weight: m.weight, distance: dist, cost: cost });
            });

            // 工廠至市場運費
            const productDist = distance(location, market);
            // 這裡 transportCost 也影響製成品運費 (經典韋伯模型)
            productCost = productWeight * productDist * transportCost;

            totalCost = materialCost + productCost;

            return { totalCost, materialCost, productCost, materialDetails, productDist, productWeight };
        };


        // 主要計算函數
        function calculateOptimalLocation() {
            if (materials.length === 0) {
                return { optimalPoint: { x: 0, y: 0 }, laborFactor: 1.0, agglomerationFactor: 1.0, laborLocation: false, agglomerationLocation: false };
            }

            // 確保使用最新的全局變量
            updateGlobalParamsFromUI();

            let totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
            const productWeight = totalInputWeight * (1 - weightLoss/100);

            // 1. 計算運輸成本最小化的位置 (P*) - 加權平均法
            let numeratorX = productWeight * market.x;
            let numeratorY = productWeight * market.y;
            let denominator = productWeight;

            materials.forEach(m => {
                numeratorX += m.weight * m.x;
                numeratorY += m.weight * m.y;
                denominator += m.weight;
            });

            let optimalX = numeratorX / denominator;
            let optimalY = numeratorY / denominator;

            let optimalPoint = { x: optimalX, y: optimalY };

            // 2. 計算基礎運輸成本 (在 P* 點)
            const baseTransportCost = calculateTransportCostDetails(optimalPoint).totalCost;
            let currentOptimalPoint = optimalPoint;

            // 3. 考慮勞動力成本偏離
            let laborFactor = 1.0;
            let laborLocation = false;

            if (laborSavings !== 'none') {
                const baseLaborSavingFactor = getLaborSavingFactor(laborSavings);
                const intensityModifier = 0.8 + (laborIntensity / 100) * 0.4;
                const adjustedLaborSavingFactor = Math.max(0.6, Math.min(0.95, baseLaborSavingFactor * intensityModifier));

                const laborZonePoint = { x: laborZone.x, y: laborZone.y };
                const laborZoneTransportCost = calculateTransportCostDetails(laborZonePoint).totalCost;

                // P* 點的混合成本 (純運輸，未應用勞動力節省)
                const pStarCostMixed = calculateFinalCost(optimalPoint, 1.0, 1.0);

                // 勞動力區的混合成本
                const laborZoneCostMixed = calculateFinalCost(laborZonePoint, adjustedLaborSavingFactor, 1.0);

                if (laborZoneCostMixed < pStarCostMixed) {
                    currentOptimalPoint = laborZonePoint;
                    laborFactor = adjustedLaborSavingFactor;
                    laborLocation = true;
                }
            }

            // 4. 考慮聚集效應偏離
            let agglomerationFactor = 1.0;
            let agglomerationLocation = false;

            if (agglomeration !== 'none') {
                const baseAgglomSavingFactor = getAgglomerationFactor(agglomeration);
                const specModifier = 0.9 + (industrySpecialization / 100) * 0.2;
                const adjustedAgglomSavingFactor = Math.max(0.7, Math.min(0.98, baseAgglomSavingFactor * specModifier));

                const agglomZonePoint = { x: agglomerationZone.x, y: agglomerationZone.y };

                // 計算當前最佳點 (可能是 P* 或勞動力區) 的成本
                let currentCostAgglomCheck = calculateFinalCost(currentOptimalPoint, laborFactor, 1.0);

                // 確定聚集區的勞動力因素
                let agglomZoneLaborFactor = 1.0;
                if (laborSavings !== 'none' && isPointInCircle(agglomZonePoint, laborZone)) {
                    // 如果聚集區在勞動力區內，則應用勞動力節省
                    const baseLaborSavingFactor = getLaborSavingFactor(laborSavings);
                    const intensityModifier = 0.8 + (laborIntensity / 100) * 0.4;
                    agglomZoneLaborFactor = Math.max(0.6, Math.min(0.95, baseLaborSavingFactor * intensityModifier));
                }

                // 聚集區的總成本 (應用勞動力和聚集效應)
                const agglomZoneTotalCost = calculateFinalCost(agglomZonePoint, agglomZoneLaborFactor, adjustedAgglomSavingFactor);

                if (agglomZoneTotalCost < currentCostAgglomCheck) {
                    currentOptimalPoint = agglomZonePoint;
                    agglomerationFactor = adjustedAgglomSavingFactor;
                    agglomerationLocation = true;

                    // 更新勞動力因素狀態 (如果因遷移到聚集區而改變)
                    laborFactor = agglomZoneLaborFactor;
                    laborLocation = agglomZoneLaborFactor < 1.0;
                }
            }

            // 設置最終最佳點
            optimal.x = currentOptimalPoint.x;
            optimal.y = currentOptimalPoint.y;

            // 返回最終的成本和分析數據
            return {
                optimalPoint: optimal,
                laborFactor,
                agglomerationFactor,
                laborLocation,
                agglomerationLocation
            };
        }

        // 計算最終點的總成本（應用勞動力和聚集效應）
        function calculateFinalCost(location, laborFactor, agglomerationFactor) {
            const details = calculateTransportCostDetails(location);
            const transportCost = details.totalCost;

            // 勞動力成本部分
            let laborCostPortion = transportCost * laborCostWeight * laborFactor;

            // 運輸成本部分 (非勞動成本部分)
            let transportOnlyCost = transportCost * (1 - laborCostWeight);

            // 應用聚集效應
            let totalCost = (transportOnlyCost + laborCostPortion) * agglomerationFactor;
            return totalCost;
        }


        // --- 結果渲染函數 (與計算分離) ---

        function calculateAndRenderResults(shouldSave = true) {

            if (materials.length === 0) return;

            // 啟動 loading 提示 (如果是拖曳或參數變動引起的)
            if (shouldSave) {
                 document.getElementById('loading-indicator').style.display = 'block';
            }

            // 使用 setTimeout 確保 UI 在執行複雜計算前更新
            setTimeout(() => {

                const analysis = calculateOptimalLocation();

                // 重新計算最終點的詳細成本，確保數據是最新的
                const finalCostDetails = calculateTransportCostDetails(analysis.optimalPoint);
                const finalTransportCost = finalCostDetails.totalCost;

                const finalTotalCost = calculateFinalCost(analysis.optimalPoint, analysis.laborFactor, analysis.agglomerationFactor);

                // --- 1. 基礎結果 ---

                const resultElement = document.getElementById('optimal-location');
                resultElement.innerHTML = `
                    <p><strong>最佳工業區位：</strong> 坐標(${Math.round(optimal.x)}, ${Math.round(optimal.y)})</p>
                    <p><strong>總運輸成本 (未修正)：</strong> ${finalTransportCost.toFixed(2)} 元</p>
                    <p><strong>最終總成本：</strong> ${finalTotalCost.toFixed(2)} 元</p>
                `;

                // --- 2. 成本明細 ---

                const costBreakdown = document.getElementById('cost-breakdown');

                let materialCostDetailsHTML = `<strong>原料運輸成本（原料產地至工廠）：</strong>`;
                let totalMaterialCost = 0;

                finalCostDetails.materialDetails.forEach(m => {
                    materialCostDetailsHTML += `<p style="margin: 3px 0 3px 15px;">原料${m.label}：${m.cost.toFixed(2)} 元 (${m.weight.toFixed(1)}噸 x ${m.distance.toFixed(1)}km)</p>`;
                    totalMaterialCost += m.cost;
                });

                const productCostDetail = `
                    <p><strong>製成品運輸成本（工廠至市場）：</strong></p>
                    <p style="margin: 3px 0 3px 15px;">到市場：${finalCostDetails.productCost.toFixed(2)} 元 (${finalCostDetails.productWeight.toFixed(1)}噸 x ${finalCostDetails.productDist.toFixed(1)}km)</p>
                `;

                costBreakdown.innerHTML = `
                    <h4>成本明細：</h4>
                    <p>原料總重量：${finalCostDetails.materialDetails.reduce((sum, m) => sum + m.weight, 0).toFixed(1)} 噸 | 製成品重量：${finalCostDetails.productWeight.toFixed(1)} 噸 (損失率${weightLoss}%)</p>
                    <p>運輸成本率：每公里每噸${transportCost.toFixed(1)}元</p>
                    <hr>
                    ${materialCostDetailsHTML}
                    <p style="font-weight: bold; margin-top: 5px;">原料運輸總額：${totalMaterialCost.toFixed(2)} 元</p>
                    ${productCostDetail}
                    <p style="font-weight: bold; margin-top: 5px;">製成品運輸總額：${finalCostDetails.productCost.toFixed(2)} 元</p>
                    <hr>
                    基礎運輸總成本：${finalTransportCost.toFixed(2)} 元<br>
                    勞動力成本佔比: ${(laborCostWeight * 100).toFixed(0)}% (實際節省係數: ${analysis.laborFactor.toFixed(2)})<br>
                    聚集效應節省係數: ${analysis.agglomerationFactor.toFixed(2)}
                `;

                // --- 3. 因素分析 (這部分略為簡化，讓核心功能更突出) ---

                const factorComparison = document.getElementById('factor-comparison');
                // 必須重新計算，因為 laborLocation/agglomerationLocation 現在由 analysis 返回
                let comparisonHTML = '';
                if (analysis.laborLocation || analysis.agglomerationLocation) {
                    comparisonHTML += `<h4>韋伯理論因素影響力分析：</h4>`;
                    comparisonHTML += `<p>最佳區位 (O) 偏離了純粹的運輸成本最低點 (P*)。</p>`;

                    if (analysis.laborLocation) {
                        comparisonHTML += `<p>✓ <strong>勞動力偏離成功：</strong> 勞動力成本的節省足以抵消增加的運輸成本。</p>`;
                    }
                    if (analysis.agglomerationLocation) {
                        comparisonHTML += `<p>✓ <strong>聚集效應偏離成功：</strong> 聚集效應的間接節省足以抵消增加的運輸成本（或進一步降低現有成本）。</p>`;
                    }
                } else {
                    comparisonHTML = `
                        <h4>韋伯理論因素影響力分析：</h4>
                        <p>在此情境下，<strong>運輸成本</strong>是唯一影響選址的因素。</p>
                        <p>這符合韋伯理論的基本假設，在勞動力或集聚效應不足以抵消額外運輸成本時，工廠區位取決於原料和市場的相對位置及權重。</p>
                    `;
                }
                factorComparison.innerHTML = comparisonHTML;

                // 4. 更新地圖和歷史記錄
                drawCanvas();

                if (shouldSave) {
                    saveCurrentState();
                }

                document.getElementById('loading-indicator').style.display = 'none';

            }, 50);
        }

        // 自動計算和存儲
        const autoCalculateAndStore = () => {
            calculateAndRenderResults(true);
        };

        // --- 綁定事件和初始化 ---

        window.onload = function() {
            // 初始設定兩個原料點
            materials.push({ id: generateUniqueId('M'), x: 100, y: 100, weight: 3, color: '#e74c3c', label: 'A' });
            materials.push({ id: generateUniqueId('M'), x: 450, y: 100, weight: 2, color: '#2ecc71', label: 'B' });
            market.x = 275;
            market.y = 400;

            const container = document.getElementById('canvas-container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;

            initResizers();
            renderMaterialList();

            // 初始計算並儲存第一個狀態
            autoCalculateAndStore();


            // --- 綁定 UI 事件 (即時計算) ---

            document.getElementById('add-material-btn').addEventListener('click', function() {
                addMaterial();
            });

            // 綁定所有 slider 和 select 元素
            const controlElements = [
                'weight-loss', 'transport-cost', 'labor-cost-weight',
                'labor-savings', 'labor-intensity', 'agglomeration', 'industry-specialization'
            ];

            controlElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function(e) {
                        // **關鍵修正：** 更新 UI 顯示，並立即觸發計算
                        const value = e.target.value;

                        // 更新顯示值
                        document.getElementById(`${id}-value`) && (document.getElementById(`${id}-value`).textContent = id.includes('loss') || id.includes('intensity') || id.includes('specialization') ? `${value}%` : (id === 'labor-cost-weight' || id === 'transport-cost' ? parseFloat(value).toFixed(1) : value));

                        // 處理下拉選單顯示/隱藏
                        if (id === 'labor-savings') {
                            document.getElementById('labor-intensity-container').style.display = value === 'none' ? 'none' : 'block';
                        }
                        if (id === 'agglomeration') {
                            document.getElementById('specialization-container').style.display = value === 'none' ? 'none' : 'block';
                        }

                        // 參數變更後，觸發計算
                        autoCalculateAndStore();
                    });

                    // 針對下拉菜單和 Range 以外的 input 類型（如 select）使用 change
                    if (element.tagName === 'SELECT') {
                        element.addEventListener('change', autoCalculateAndStore);
                    }
                }
            });

            // 歷史記錄按鈕
            STEP_BACK_BTN.addEventListener('click', restorePreviousState);

            // 鍵盤快捷鍵 (Ctrl/Cmd + Z)
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    restorePreviousState();
                }
            });


            document.getElementById('reset-btn').addEventListener('click', function() {
                // 重置邏輯保持不變，並確保在結束時調用 autoCalculateAndStore
                materials = [
                    { id: generateUniqueId('M'), x: 100, y: 100, weight: 3, color: '#e74c3c', label: 'A' },
                    { id: generateUniqueId('M'), x: 450, y: 100, weight: 2, color: '#2ecc71', label: 'B' }
                ];
                market = { x: 275, y: 400, label: '市場', color: '#3498db', weight: 1 };
                optimal = { x: 0, y: 0, label: 'O', color: '#9b59b6' };

                // 重置全局變量
                weightLoss = 30; transportCost = 5; laborCostWeight = 0.3; laborSavings = 'none';
                laborIntensity = 50; agglomeration = 'none'; industrySpecialization = 50;
                laborZone = { x: 150, y: 200, radius: 0 };
                agglomerationZone = { x: 450, y: 220, radius: 0 };

                historyStack = [];

                // 重置 UI
                updateUIFromState();

                // 清空分析結果
                document.getElementById('optimal-location').innerHTML = '<p>調整參數或拖曳地圖上的點，結果將即時更新。</p>';
                document.getElementById('cost-breakdown').innerHTML = '';
                document.getElementById('factor-comparison').innerHTML = '';
                document.getElementById('labor-analysis').style.display = 'none';
                document.getElementById('agglom-analysis').style.display = 'none';

                drawCanvas();
                autoCalculateAndStore(); // 儲存初始狀態
            });

            document.getElementById('show-theory-btn').addEventListener('click', function() {
                const theoryExplanation = document.getElementById('theory-explanation');
                if (theoryExplanation.style.display === 'none') {
                    theoryExplanation.style.display = 'block';
                    this.textContent = '隱藏韋伯理論說明';
                } else {
                    theoryExplanation.style.display = 'none';
                    this.textContent = '顯示韋伯理論說明';
                }
            });

            document.getElementById('toggle-debug').addEventListener('click', function() {
                debugMode = !debugMode;
                const debugInfo = document.getElementById('debug-info');
                if (debugMode) {
                    debugInfo.style.display = 'block';
                    this.textContent = '隱藏調試信息';
                } else {
                    debugInfo.style.display = 'none';
                    this.textContent = '顯示調試信息';
                }
            });

            // --- 畫布拖曳邏輯 ---

            function findPointAt(x, y) {
                // 檢查市場點
                const distM = distance({x, y}, market);
                if (distM < 15) return { type: 'market', point: market };

                // 檢查原料點
                for (const m of materials) {
                    const dist = distance({x, y}, m);
                    if (dist < 15) return { type: 'material', point: m };
                }

                // 檢查勞動力區中心
                if (laborSavings !== 'none') {
                    const distLabor = distance({x, y}, laborZone);
                    if (distLabor < 15) return { type: 'laborZone', point: laborZone };
                }

                // 檢查聚集區中心
                if (agglomeration !== 'none') {
                    const distAgglom = distance({x, y}, agglomerationZone);
                    if (distAgglom < 15) return { type: 'agglomerationZone', point: agglomerationZone };
                }

                return null;
            }

            let dragTimeout;

            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const clicked = findPointAt(x, y);
                if (clicked) {
                    isDragging = true;
                    selectedPoint = clicked;
                    if (dragTimeout) clearTimeout(dragTimeout);
                }
            });

            canvas.addEventListener('mousemove', function(e) {
                if (isDragging && selectedPoint) {
                    const rect = canvas.getBoundingClientRect();
                    const newX = e.clientX - rect.left;
                    const newY = e.clientY - rect.top;

                    const clampedX = Math.max(20, Math.min(canvas.width - 20, newX));
                    const clampedY = Math.max(20, Math.min(canvas.height - 20, newY));

                    const snappedPoint = snapToGrid(clampedX, clampedY);

                    // **修復點位更新：直接修改 selectedPoint.point 的 x/y**
                    selectedPoint.point.x = snappedPoint.x;
                    selectedPoint.point.y = snappedPoint.y;

                    drawCanvas();

                    if (dragTimeout) clearTimeout(dragTimeout);
                    dragTimeout = setTimeout(autoCalculateAndStore, 150);
                }
            });

            canvas.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    selectedPoint = null;
                    if (dragTimeout) clearTimeout(dragTimeout);
                    autoCalculateAndStore();
                }
            });

            // 觸控邏輯
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const clicked = findPointAt(x, y);
                if (clicked) {
                    isDragging = true;
                    selectedPoint = clicked;
                    if (dragTimeout) clearTimeout(dragTimeout);
                }
            });

            canvas.addEventListener('touchmove', function(e) {
                if (isDragging && selectedPoint) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const newX = touch.clientX - rect.left;
                    const newY = touch.clientY - rect.top;

                    const clampedX = Math.max(20, Math.min(canvas.width - 20, newX));
                    const clampedY = Math.max(20, Math.min(canvas.height - 20, newY));

                    const snappedPoint = snapToGrid(clampedX, clampedY);

                    selectedPoint.point.x = snappedPoint.x;
                    selectedPoint.point.y = snappedPoint.y;

                    drawCanvas();

                    if (dragTimeout) clearTimeout(dragTimeout);
                    dragTimeout = setTimeout(autoCalculateAndStore, 150);
                }
            });

            canvas.addEventListener('touchend', function() {
                if (isDragging) {
                    isDragging = false;
                    selectedPoint = null;
                    if (dragTimeout) clearTimeout(dragTimeout);
                    autoCalculateAndStore();
                }
            });

            // 響應窗口大小變化
            window.addEventListener('resize', function() {
                const container = document.getElementById('canvas-container');
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
                drawCanvas();
                // 窗口大小變化不應導致歷史記錄增加，但需要重新計算以避免點位超出邊界
                calculateAndRenderResults(false);
            });
        };

        // Resizer 函數保持不變
        function snapToGrid(x, y) {
            const SNAP_THRESHOLD = 15;
            const gridX = Math.round(x / GRID_SIZE) * GRID_SIZE;
            const gridY = Math.round(y / GRID_SIZE) * GRID_SIZE;
            const distToGrid = Math.sqrt(Math.pow(x - gridX, 2) + Math.pow(y - gridY, 2));

            if (distToGrid < SNAP_THRESHOLD) {
                return { x: gridX, y: gridY };
            }
            return { x: x, y: y };
        }

        function initResizers() {
            const mapControlResizer = document.getElementById('map-control-resizer');
            const mapSection = document.getElementById('map-section');
            const canvasContainer = document.getElementById('canvas-container');

            let isHorizontalResizing = false;
            let startY, startMapHeight;

            mapControlResizer.addEventListener('mousedown', function(e) {
                isHorizontalResizing = true;
                startY = e.clientY;
                startMapHeight = mapSection.offsetHeight;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'ns-resize';
            });

            const columnResizer = document.getElementById('column-resizer');
            const leftColumn = document.getElementById('left-column');
            const mainContainer = document.getElementById('main-container');

            let isVerticalResizing = false;
            let startX, startLeftWidth;

            columnResizer.addEventListener('mousedown', function(e) {
                isVerticalResizing = true;
                startX = e.clientX;
                startLeftWidth = leftColumn.offsetWidth;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'ew-resize';
            });

            document.addEventListener('mousemove', function(e) {
                if (isHorizontalResizing) {
                    const deltaY = e.clientY - startY;
                    const containerHeight = mainContainer.offsetHeight;
                    const totalPadding = 40;

                    const maxMapHeight = containerHeight * 0.7 - totalPadding;
                    const newMapHeight = Math.max(150, Math.min(startMapHeight + deltaY, maxMapHeight));

                    mapSection.style.height = newMapHeight + 'px';

                    canvasContainer.style.height = (newMapHeight - 30) + 'px';
                    canvas.height = newMapHeight - 30;

                    drawCanvas();
                }

                if (isVerticalResizing) {
                    const deltaX = e.clientX - startX;
                    const containerWidth = mainContainer.offsetWidth;
                    const newLeftWidth = Math.max(300, Math.min(startLeftWidth + deltaX, containerWidth - 300));
                    const leftPercentage = (newLeftWidth / containerWidth) * 100;

                    mainContainer.style.gridTemplateColumns = `${leftPercentage}% auto`;

                    canvas.width = canvasContainer.offsetWidth;
                    drawCanvas();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isHorizontalResizing || isVerticalResizing) {
                    isHorizontalResizing = false;
                    isVerticalResizing = false;
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                    window.dispatchEvent(new Event('resize'));
                }
            });

            mapControlResizer.addEventListener('touchstart', (e) => {
                isHorizontalResizing = true;
                startY = e.touches[0].clientY;
                startMapHeight = mapSection.offsetHeight;
                e.preventDefault();
            });
            columnResizer.addEventListener('touchstart', (e) => {
                isVerticalResizing = true;
                startX = e.touches[0].clientX;
                startLeftWidth = leftColumn.offsetWidth;
                e.preventDefault();
            });
        }

    </script>
</body>
</html>
