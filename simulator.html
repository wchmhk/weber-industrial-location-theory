<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>韋伯工業區位理論模擬器 - 多原料版 (即時計算)</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --primary-color-dark: #4a49b0;
            --background-color: #f8f9fa;
            --card-color: #ffffff;
            --text-color: #333333;
            --secondary-text: #666666;
            --border-color: #ddd;
            --labor-color: rgba(255, 180, 0, 0.8);
            --labor-bg: rgba(255, 240, 200, 0.3);
            --agglom-color: rgba(0, 120, 255, 0.8);
            --agglom-bg: rgba(200, 240, 255, 0.3);
            --material-border: #999;
            --primary-color-rgb: 93, 92, 222;
        }

        .dark {
            --primary-color: #7b7aef;
            --primary-color-dark: #6665d9;
            --background-color: #181818;
            --card-color: #292929;
            --text-color: #e0e0e0;
            --secondary-text: #b0b0b0;
            --border-color: #444;
            --labor-color: rgba(255, 180, 0, 0.9);
            --labor-bg: rgba(255, 180, 0, 0.15);
            --agglom-color: rgba(70, 150, 255, 0.9);
            --agglom-bg: rgba(70, 150, 255, 0.15);
            --material-border: #666;
            --primary-color-rgb: 123, 122, 239;
        }

        html, body {
            font-family: 'Microsoft YaHei', '微軟正黑體', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            height: 100%;
            /* 允許整個應用程式容器滾動，以應對高度不足的情況 */
            overflow-y: auto;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: visible;
        }

        .title-container {
            flex: 0 0 auto;
            margin-bottom: 5px; /* 減少底部間距 */
        }

        h1 {
            color: var(--text-color);
            font-size: 24px; /* 縮小標題字體 */
            margin-top: 5px; /* 減少 H1 上邊距 */
            margin-bottom: 5px; /* 減少 H1 下邊距 */
        }

        h2, h3, h4 {
            color: var(--text-color);
            margin-top: 0;
        }

        /* 調整 H2 以適應按鈕並排 */
        .results-section h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            flex: 1;
            overflow: visible;
        }

        .left-column {
            grid-column: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-height: 500px;
        }

        .map-section, .control-section, .results-section {
            background: var(--card-color);
            border-radius: 8px;
            /* 調整 padding 以節省空間 */
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        .control-section {
             /* 允許 controls 內部內容滾動 */
            overflow: hidden;
        }

        .control-tabs {
            display: flex;
            margin-bottom: 5px; /* 減少間距 */
            border-bottom: 1px solid var(--border-color);
        }

        .control-tabs button {
            flex: 1;
            background: transparent;
            color: var(--secondary-text);
            border: none;
            border-bottom: 3px solid transparent;
            /* 略微減少 padding */
            padding: 8px 15px;
            font-size: 16px;
            transition: all 0.2s ease;
            margin-bottom: -1px;
            white-space: nowrap;
        }

        .control-tabs button.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
            font-weight: bold;
        }
        .control-tabs button:hover:not(.active) {
            background-color: rgba(var(--primary-color-rgb, 93, 92, 222), 0.1);
        }

        .control-panel-content {
            padding-top: 5px;
        }

        .scrollable-content {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--background-color);
        }

        #canvas-container {
            width: 100%;
            aspect-ratio: 550 / 400;
            /* 允許 resizer 調整高度，但設置上限 */
            max-height: 320px;
            background-color: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .map-section {
            height: auto;
            min-height: 250px;
            flex-shrink: 0; /* 確保在 flex column 中不會被控制面板擠壓 */
        }

        /* 桌面模式下，為地圖設定一個適合 6 個網格的高度 (~300px + padding) */
        @media (min-width: 901px) {
            .map-section {
                height: 350px !important; /* 使用 350px 作為標準，保持視覺平衡 */
            }
            #canvas-container {
                max-height: 320px;
                height: 100%;
            }
        }


        canvas {
            display: block;
            background-color: var(--card-color);
            transition: background-color 0.3s ease;
            width: 100%;
            height: 100%;
        }

        .results-section {
            grid-column: 2;
            grid-row: 1 / span 2;
        }

        .results-section .scrollable-content {
             /* 讓結果區塊內容可以滾動 */
            overflow-y: auto;
        }

        .controls {
            margin-top: 5px;
        }

        .parameters-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            /* 減少垂直間距 */
            gap: 5px 15px;
            align-items: center;
        }

        /* 減少控制面板內標題的空間 */
        .control-panel-content h3 {
            margin-top: 10px !important;
            margin-bottom: 5px;
            font-size: 1.1em;
        }


        .full-width {
            grid-column: 1 / span 2;
        }

        /* ------------------ Results Enhancement ------------------ */
        .results {
            margin-top: 10px;
        }

        .result-box {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            background-color: var(--background-color);
            transition: background-color 0.3s ease;
        }

        .result-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px 10px; /* 減少間距 */
            font-size: 14px;
            margin-top: 5px;
        }
        .result-table strong {
            color: var(--text-color);
            font-weight: normal;
        }
        .result-table .header {
            grid-column: 1 / span 2;
            font-weight: bold;
            margin-top: 5px;
            color: var(--primary-color);
        }
        .result-table .total-row {
            grid-column: 1 / span 2;
            border-top: 1px dashed var(--border-color);
            padding-top: 5px;
            margin-top: 5px;
            font-weight: bold;
        }

        #material-manager {
            border: 1px solid var(--border-color);
            /* 略微減少 padding */
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px; /* 減少間距 */
            grid-column: 1 / span 2;
            background-color: var(--background-color);
        }

        .material-item {
            display: grid;
            grid-template-columns: 50px 1fr auto;
            align-items: center;
            gap: 10px;
            margin-bottom: 3px; /* 減少間距 */
            padding: 3px 0; /* 減少 padding */
            border-bottom: 1px dashed var(--border-color);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px; /* 減少間距 */
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .button-group button {
            flex: 1 1 45%;
            min-width: 120px;
        }

        /* 調整滑塊容器，減少垂直空間佔用 */
        .slider-container {
            padding: 2px 0;
            display: flex;
            align-items: center;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
            margin-right: 10px;
        }


        /* ------------------ Responsive Adjustments ------------------ */

        @media (max-width: 900px) {
            .app-container {
                min-height: initial;
            }
            .container {
                grid-template-columns: 1fr;
                overflow: visible;
            }
            .left-column, .results-section {
                grid-column: 1;
                width: 100%;
                margin-top: 0;
                /* 確保在窄屏下，左右兩列都能有內容高度 */
                min-height: initial;
            }
            .results-section {
                grid-row: auto;
                min-height: initial;
            }

            .horizontal-resizer, .vertical-resizer {
                display: none;
            }

            .map-section {
                height: auto !important;
                flex: none;
            }
            #canvas-container {
                height: auto;
            }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <div class="title-container">
            <h1>韋伯工業區位理論互動模擬器 (多原料版 / 即時計算)</h1>
        </div>
        <div class="container" id="main-container" style="grid-template-columns: 67% 33%;">
        <div class="left-column" id="left-column">
            <!-- 移除 inline style="height: 38%"，交由 CSS 控制其高度 -->
            <div class="map-section" id="map-section">
                <div id="canvas-container">
                    <canvas id="weberCanvas" width="550" height="400"></canvas>
                </div>
            </div>

            <!-- 水平分隔線 (窄螢幕隱藏) -->
            <div class="resizer horizontal-resizer" id="map-control-resizer">
                <div class="resizer-handle"></div>
            </div>

            <div class="control-section" id="control-section" style="flex: 1;">

                <div class="control-tabs">
                    <button id="tab-transport-btn" class="active">原料/製品 (運輸因素)</button>
                    <button id="tab-deviation-btn">勞動力/聚集 (偏離因素)</button>
                </div>

                <div class="scrollable-content">
                    <!-- 運輸因素控制面板 -->
                    <div id="transport-controls" class="control-panel-content">
                        <div class="controls">
                            <div id="material-manager" class="full-width">
                                <label><strong>原料產地設定 (拖曳地圖上的點修改位置)</strong></label>
                                <div id="material-list-container">
                                    <!-- Dynamic material inputs will be injected here -->
                                </div>
                                <button id="add-material-btn" class="add-material-btn">新增原料產地</button>
                            </div>

                            <div class="parameters-grid">

                                <!-- 新增製品/市場(M)的重量控制項 -->
                                <label for="market-weight">製品/市場(M)重量 (噸)</label>
                                <div class="slider-container">
                                    <input type="range" id="market-weight" min="0.5" max="10" value="3.5" step="0.1">
                                    <span id="market-weight-value" class="slider-value">3.5 噸</span>
                                </div>

                                <!-- 移除重量損失率控制項 -->

                                <label for="transport-cost">運輸成本 (每公里/噸)</label>
                                <div class="slider-container">
                                    <input type="range" id="transport-cost" min="1" max="10" value="5" step="0.5">
                                    <span id="transport-cost-value" class="slider-value">5.0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 偏離因素控制面板 -->
                    <div id="deviation-controls" class="control-panel-content" style="display:none;">
                        <div class="controls">
                            <div class="parameters-grid">

                                <!-- 勞動力因素 -->
                                <!-- 調整標題 margin -->
                                <h3 class="full-width labor-control">勞動力影響 (勞動力成本權重)</h3>

                                <label for="labor-cost-weight">勞動力成本佔總成本權重</label>
                                <div class="slider-container">
                                    <input type="range" id="labor-cost-weight" min="0" max="1" value="0.3" step="0.1">
                                    <span id="labor-cost-weight-value" class="slider-value">0.3</span>
                                </div>

                                <label for="labor-savings" class="labor-label">勞動力優勢區節省潛力</label>
                                <div class="slider-container">
                                    <select id="labor-savings">
                                        <option value="none">無勞動力優勢區</option>
                                        <option value="light">輕微 (10% 節省)</option>
                                        <option value="moderate">中等 (20% 節省)</option>
                                        <option value="significant">顯著 (30% 節省)</option>
                                        <option value="dominant">主導 (40% 節省)</option>
                                    </select>
                                </div>

                                <div id="labor-intensity-container" class="full-width" style="display:none;">
                                    <label for="labor-intensity">工廠勞動力密集程度 (影響節省效果)</label>
                                    <div class="slider-container">
                                        <input type="range" id="labor-intensity" min="0" max="100" value="50" step="10">
                                        <span id="labor-intensity-value" class="slider-value">50%</span>
                                    </div>
                                </div>

                                <!-- 聚集因素 -->
                                <!-- 調整標題 margin -->
                                <h3 class="full-width agglom-control">聚集因素影響 (間接成本節省)</h3>

                                <label for="agglomeration" class="agglom-label">聚集經濟潛力</label>
                                <div class="slider-container">
                                    <select id="agglomeration">
                                        <option value="none">無聚集效應</option>
                                        <option value="light">輕微 (5% 節省)</option>
                                        <option value="moderate">中等 (15% 節省)</option>
                                        <option value="significant">顯著 (25% 節省)</option>
                                    </select>
                                </div>

                                <div id="specialization-container" class="full-width" style="display:none;">
                                    <label for="industry-specialization">產業專業化程度 (影響節省效果)</label>
                                    <div class="slider-container">
                                        <input type="range" id="industry-specialization" min="0" max="100" value="50" step="10">
                                        <span id="industry-specialization-value" class="slider-value">50%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="button-group">
                    <button id="step-back-btn" disabled>上一步 (Ctrl/Cmd+Z)</button>
                    <button id="reset-btn">重置模擬</button>
                    <button id="toggle-debug" style="background-color:#888">顯示調試信息</button>
                    <button id="show-theory-btn">顯示韋伯理論說明</button>
                </div>

                <div id="debug-info"></div>
            </div>
        </div>

        <!-- 垂直分隔線 (窄螢幕隱藏) -->
        <div class="resizer vertical-resizer" id="column-resizer">
            <div class="resizer-handle"></div>
        </div>

        <div class="results-section" id="results-section">
            <!-- 新增按鈕容器 -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2>分析結果</h2>
                <button id="find-optimal-btn" style="padding: 5px 10px; font-size: 14px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer;">
                    找到最低成本點 (P*/O)
                </button>
            </div>
            <div class="scrollable-content">

            <div id="theory-explanation" style="display:none;" class="info-panel">
                <h3>韋伯工業區位理論 (Weber's Industrial Location Theory)</h3>
                <p>阿爾弗雷德·韋伯(Alfred Weber)於1909年提出的理論，旨在尋找總成本最低的工廠區位，主要考慮三個因素：</p>
                <ol>
                    <li><strong>運輸成本 (主導因素)</strong>：原料運費 + 製成品運費。區位點由原料和製成品重量的權重決定。</li>
                    <li><strong>勞動力成本偏離</strong>：如果某地勞動力成本節省額度，大於因此增加的運輸成本，則工廠會偏離運輸成本最低點。</li>
                    <li><strong>聚集經濟偏離</strong>：如果聚集帶來的間接成本節省，大於因此增加的運輸成本，則工廠會偏離。</li>
                </ol>
                <p>此模擬器使用韋伯多角形模型計算運輸成本最低點，並通過成本比較來判斷勞動力和聚集效應是否會導致區位偏離。</p>
            </div>

            <div class="results">
                <div id="optimal-location" class="result-box">
                    <p>調整參數或拖曳地圖上的點，結果將即時更新。</p>
                </div>

                <div id="factor-comparison" class="result-box"></div>

                <div id="cost-breakdown" class="result-box"></div>

                <div id="labor-analysis" class="result-box labor-control" style="display:none;">
                    <h4>勞動力影響分析</h4>
                    <div id="labor-impact-detail"></div>
                </div>

                <div id="agglom-analysis" class="result-box agglom-control" style="display:none;">
                    <h4>聚集效應影響分析</h4>
                    <div id="agglom-impact-detail"></div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        // 檢測暗黑模式偏好
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        const canvas = document.getElementById('weberCanvas');
        const ctx = canvas.getContext('2d');
        const STEP_BACK_BTN = document.getElementById('step-back-btn');

        // --- 核心數據結構 ---
        let materials = [];
        // 製品重量現在是獨立輸入
        let market = { x: 275, y: 250, label: '市場(M)', color: '#3498db', weight: 3.5 };
        let optimal = { x: 0, y: 0, label: 'O', color: '#9b59b6', isManual: false };

        // 移除 weightLoss
        let transportCost = 5;
        let laborSavings = 'none';
        let laborIntensity = 50;
        let laborCostWeight = 0.3;
        let agglomeration = 'none';
        let industrySpecialization = 50;

        let laborZone = { x: 100, y: 200, radius: 0 };
        let agglomerationZone = { x: 450, y: 180, radius: 0 };

        const GRID_SIZE = 50;
        let isDragging = false;
        let selectedPoint = null;
        let debugMode = false;

        // --- 歷史記錄機制 ---
        const MAX_HISTORY = 20;
        let historyStack = [];
        let lastCalculationState = null;

        // 新增：去抖定時器
        let debounceTimer;

        // --- 輔助函數：去抖 (Debounce) ---
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // 實際執行計算的函數
        const runCalculationAndStore = () => {
            calculateAndRenderResults(true);
        };

        // 去抖後的計算函數 (只在停止操作 200ms 後執行)
        const debouncedCalculateAndStore = debounce(runCalculationAndStore, 200);


        // 自動計算和存儲 (用於單次操作或非去抖操作的入口)
        const autoCalculateAndStore = () => {
            // 對於拖曳點位，我們使用更快的 dragTimeout 進行節流
            if (isDragging) {
                // 拖曳點位時，使用節流（Throttle）
                if (dragTimeout) clearTimeout(dragTimeout);
                dragTimeout = setTimeout(runCalculationAndStore, 150);
            } else {
                // 對於其他單次操作（如按鈕點擊），立即執行
                runCalculationAndStore();
            }
        };


        function saveCurrentState() {
            updateGlobalParamsFromUI();
            const currentState = {
                materials: materials.map(m => ({ ...m })),
                market: { ...market },
                optimal: { x: optimal.x, y: optimal.y, label: optimal.label, color: optimal.color, isManual: false }, // 不保存 manual 狀態
                params: {
                    // weightLoss, // 移除
                    transportCost, laborCostWeight, laborSavings, laborIntensity, agglomeration, industrySpecialization
                },
                zones: {
                    laborZone: { ...laborZone },
                    agglomerationZone: { ...agglomerationZone }
                }
            };
            const currentStateJSON = JSON.stringify(currentState);
            if (lastCalculationState === currentStateJSON) return;
            if (historyStack.length >= MAX_HISTORY) {
                historyStack.shift();
            }
            historyStack.push(currentState);
            lastCalculationState = currentStateJSON;
            STEP_BACK_BTN.disabled = historyStack.length <= 1;
        }

        function restorePreviousState() {
            if (historyStack.length <= 1) return;
            historyStack.pop();
            const prevState = historyStack[historyStack.length - 1];

            // weightLoss = prevState.params.weightLoss; // 移除
            transportCost = prevState.params.transportCost;
            laborCostWeight = prevState.params.laborCostWeight;
            laborSavings = prevState.params.laborSavings;
            laborIntensity = prevState.params.laborIntensity;
            agglomeration = prevState.params.agglomeration;
            industrySpecialization = prevState.params.industrySpecialization;

            materials = prevState.materials.map(m => ({ ...m }));
            market = { ...prevState.market };
            optimal = { ...prevState.optimal, isManual: false }; // 恢復狀態時取消 manual 模式
            laborZone = { ...prevState.zones.laborZone };
            agglomerationZone = { ...prevState.zones.agglomerationZone };

            updateUIFromState();
            STEP_BACK_BTN.disabled = historyStack.length <= 1;
            calculateAndRenderResults(false);
        }

        function updateUIFromState() {
            // 移除 weight-loss 相關更新

            // 新增 market-weight UI 更新
            const marketWeightInput = document.getElementById('market-weight');
            if (marketWeightInput) {
                marketWeightInput.value = market.weight;
                document.getElementById('market-weight-value').textContent = market.weight.toFixed(1) + ' 噸';
            }

            document.getElementById('transport-cost').value = transportCost;
            document.getElementById('transport-cost-value').textContent = transportCost.toFixed(1);

            document.getElementById('labor-cost-weight').value = laborCostWeight;
            document.getElementById('labor-cost-weight-value').textContent = laborCostWeight.toFixed(1);
            document.getElementById('labor-savings').value = laborSavings;
            document.getElementById('labor-intensity-container').style.display = laborSavings === 'none' ? 'none' : 'block';
            document.getElementById('labor-intensity').value = laborIntensity;
            document.getElementById('labor-intensity-value').textContent = laborIntensity + '%';

            document.getElementById('agglomeration').value = agglomeration;
            document.getElementById('specialization-container').style.display = agglomeration === 'none' ? 'none' : 'block';
            document.getElementById('industry-specialization').value = industrySpecialization;
            document.getElementById('industry-specialization-value').textContent = industrySpecialization + '%';

            renderMaterialList();
            drawCanvas();
        }

        function updateGlobalParamsFromUI() {
            // weightLoss = parseInt(document.getElementById('weight-loss').value); // 移除

            // 新增 marketWeight 更新
            const marketWeightInput = document.getElementById('market-weight');
            if (marketWeightInput) {
                 market.weight = parseFloat(marketWeightInput.value);
            }

            transportCost = parseFloat(document.getElementById('transport-cost').value);
            laborCostWeight = parseFloat(document.getElementById('labor-cost-weight').value);
            laborSavings = document.getElementById('labor-savings').value;
            laborIntensity = parseInt(document.getElementById('labor-intensity').value);
            agglomeration = document.getElementById('agglomeration').value;
            industrySpecialization = parseInt(document.getElementById('industry-specialization').value);
        }


        // --- 輔助函數 ---

        function getLaborSavingFactor(laborSavingsType) {
            switch(laborSavingsType) {
                case 'light': return 0.90; case 'moderate': return 0.80;
                case 'significant': return 0.70; case 'dominant': return 0.60;
                default: return 1.0;
            }
        }
        function getAgglomerationFactor(agglomerationType) {
            switch(agglomerationType) {
                case 'light': return 0.95; case 'moderate': return 0.85;
                case 'significant': return 0.75; default: return 1.0;
            }
        }
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        function isPointInCircle(point, circle) {
            return distance(point, circle) <= circle.radius;
        }

        // --- 繪圖函數 ---
        function getMaterialColor(id) {
            const colors = ['#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22', '#1abc9c'];
            const index = materials.findIndex(m => m.id === id);
            return colors[index % colors.length];
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const isDarkMode = document.documentElement.classList.contains('dark');
            const gridColor = isDarkMode ? '#444444' : '#e0e0e0';
            const textColor = isDarkMode ? '#e0e0e0' : '#000000';

            // 繪製網格
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // 繪製區域 (勞動力/聚集)
            if (laborSavings !== 'none') {
                let radius;
                switch(laborSavings) {
                    case 'light': radius = 50; break; case 'moderate': radius = 70; break;
                    case 'significant': radius = 90; break; case 'dominant': radius = 110; break;
                    default: radius = 0;
                }
                radius = radius * (0.75 + (laborIntensity / 100) * 0.5);
                laborZone.radius = radius;

                const laborFillStyle = isDarkMode ? 'var(--labor-bg)' : 'rgba(255, 240, 200, 0.3)';
                const laborStrokeStyle = 'var(--labor-color)';

                ctx.beginPath();
                ctx.arc(laborZone.x, laborZone.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = laborFillStyle;
                ctx.fill();
                ctx.strokeStyle = laborStrokeStyle;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = '14px Arial';
                ctx.fillText('勞動力優勢區', laborZone.x - 45, laborZone.y - radius - 10);
            }

            if (agglomeration !== 'none') {
                let radius;
                switch(agglomeration) {
                    case 'light': radius = 50; break; case 'moderate': radius = 70; break;
                    case 'significant': radius = 90; break; default: radius = 0;
                }
                radius = radius * (0.75 + (industrySpecialization / 100) * 0.5);
                agglomerationZone.radius = radius;

                const agglomFillStyle = isDarkMode ? 'var(--agglom-bg)' : 'rgba(200, 240, 255, 0.3)';
                const agglomStrokeStyle = 'var(--agglom-color)';

                ctx.beginPath();
                ctx.arc(agglomerationZone.x, agglomerationZone.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = agglomFillStyle;
                ctx.fill();
                ctx.strokeStyle = agglomStrokeStyle;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = textColor;
                ctx.font = '14px Arial';
                ctx.fillText('產業聚集區', agglomerationZone.x - 40, agglomerationZone.y - radius - 10);
            }

            // 計算製品的實際重量
            const totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
            const actualProductWeight = market.weight;

            // 繪製韋伯多角形
            const allPoints = [...materials, market];
            if (allPoints.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(allPoints[0].x, allPoints[0].y);
                for (let i = 1; i < allPoints.length; i++) {
                    ctx.lineTo(allPoints[i].x, allPoints[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = isDarkMode ? '#777' : '#aaa';
                ctx.lineWidth = 1;
                ctx.stroke();
            }


            // 繪製所有點 (包括市場)
            const pointsToDraw = [...materials, market];
            const totalWeight = totalInputWeight + actualProductWeight;

            for (const point of pointsToDraw) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = point.color;
                ctx.fill();

                ctx.font = '16px Arial';
                ctx.fillStyle = textColor;
                // 修正：市場點在圖表上顯示 '市場(M)'
                const labelText = (point === market) ? '市場(M)' : point.label;
                ctx.fillText(labelText, point.x + 15, point.y - 5);

                // 修正單位：顯示噸
                ctx.font = '12px Arial';
                ctx.fillText(`${point.weight.toFixed(1)}噸`, point.x + 15, point.y + 15);
            }

            // 如果最佳點已計算，繪製連接線和點
            if (optimal.x || optimal.y) {
                ctx.setLineDash([5, 3]);
                materials.forEach(material => {
                    ctx.beginPath();
                    ctx.moveTo(material.x, material.y);
                    ctx.lineTo(optimal.x, optimal.y);
                    ctx.strokeStyle = material.color;
                    ctx.lineWidth = 2 + (5 * material.weight / totalWeight);
                    ctx.stroke();
                });

                ctx.beginPath();
                ctx.moveTo(market.x, market.y);
                ctx.lineTo(optimal.x, optimal.y);
                ctx.strokeStyle = market.color;
                ctx.lineWidth = 2 + (5 * actualProductWeight / totalWeight);
                ctx.stroke();

                ctx.setLineDash([]);

                // 繪製 P/P*/O 點
                ctx.beginPath();
                ctx.arc(optimal.x, optimal.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = optimal.color;
                ctx.fill();

                // 如果是手動拖曳，稍微改變樣式
                if (optimal.isManual) {
                    ctx.strokeStyle = textColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.font = '16px Arial';
                ctx.fillStyle = textColor;
                ctx.fillText(optimal.label, optimal.x + 15, optimal.y - 5);
            }
        }


        // --- 動態原料管理函數 ---

        function generateUniqueId(prefix) {
            return prefix + '_' + Date.now() + Math.floor(Math.random() * 1000);
        }

        function renderMaterialList() {
            const container = document.getElementById('material-list-container');
            container.innerHTML = '';

            // 不再計算製品重量，直接使用 market.weight

            materials.forEach((m, index) => {
                const materialDiv = document.createElement('div');
                materialDiv.className = 'material-item';
                materialDiv.dataset.id = m.id;

                const label = String.fromCharCode(65 + index);
                m.label = label;
                m.color = getMaterialColor(m.id);

                materialDiv.innerHTML = `
                    <span class="material-label" style="color: ${m.color}">原料 ${label}:</span>
                    <div class="slider-container">
                        <input type="range" id="weight-${m.id}" min="0.5" max="10" value="${m.weight}" step="0.1">
                        <span id="weight-value-${m.id}" class="slider-value">${m.weight.toFixed(1)} 噸</span>
                    </div>
                    <button class="remove-material-btn" data-id="${m.id}">移除</button>
                `;
                container.appendChild(materialDiv);

                document.getElementById(`weight-${m.id}`).addEventListener('input', function(e) {
                    const newWeight = parseFloat(e.target.value);
                    m.weight = newWeight;
                    document.getElementById(`weight-value-${m.id}`).textContent = newWeight.toFixed(1) + ' 噸';
                    debouncedCalculateAndStore(); // 使用去抖
                });
            });


            container.querySelectorAll('.remove-material-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const idToRemove = this.dataset.id;
                    materials = materials.filter(m => m.id !== idToRemove);
                    renderMaterialList();
                    autoCalculateAndStore(); // 使用非去抖，因為是單次點擊操作
                });
            });
        }

        // --- 新增原料的初始化位置邏輯 ---
        function addMaterial() {
            const newIndex = materials.length;
            const newLabel = String.fromCharCode(65 + newIndex);

            let newX, newY;

            // 嘗試找到一個不與現有資源點衝突的位置
            if (newIndex === 0) {
                newX = 150; newY = 50;
            } else if (newIndex === 1) {
                newX = 450; newY = 50;
            } else {
                // 否則，隨機找一個位置
                newX = 50 + Math.random() * (canvas.width - 100);
                newY = 50 + Math.random() * (canvas.height - 100);
            }


            const newMaterial = {
                id: generateUniqueId('M'),
                x: newX,
                y: newY,
                weight: 1.0, // 默認重量
                color: getMaterialColor(materials.length),
                label: newLabel
            };

            materials.push(newMaterial);
            renderMaterialList();
            autoCalculateAndStore();
        }


        // --- 核心計算函數 (P* 基於實際重量) ---

        const calculateTransportCostDetails = (location) => {
            updateGlobalParamsFromUI();

            let totalCost = 0;
            let materialCost = 0;
            let productCost = 0;
            let materialDetails = [];

            const totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
            const actualProductWeight = market.weight; // 直接使用市場點的重量

            // 原料至工廠運費
            materials.forEach(m => {
                const dist = distance(location, m);
                const cost = m.weight * dist * transportCost;
                materialCost += cost;
                materialDetails.push({ label: m.label, weight: m.weight, distance: dist, cost: cost });
            });

            // 工廠至市場運費 (使用實際產品重量)
            const productDist = distance(location, market);
            productCost = actualProductWeight * productDist * transportCost;

            totalCost = materialCost + productCost;

            return { totalCost, materialCost, productCost, materialDetails, productDist, actualProductWeight, totalInputWeight, x: location.x, y: location.y };
        };


        function calculateOptimalLocation() {
            if (materials.length === 0) {
                return { optimalPoint: { x: 0, y: 0 }, laborFactor: 1.0, agglomerationFactor: 1.0, laborLocation: false, agglomerationLocation: false, pStarCost: 0, lowestCost: 0, pStarPoint: {x:0, y:0} };
            }

            updateGlobalParamsFromUI();

            const totalInputWeight = materials.reduce((sum, m) => sum + m.weight, 0);
            const actualProductWeight = market.weight; // 直接使用市場重量

            // 1. 計算運輸成本最小化的位置 (P*) - 加權平均法
            const productWeightForPStar = actualProductWeight;

            let numeratorX = productWeightForPStar * market.x;
            let numeratorY = productWeightForPStar * market.y;
            let denominator = productWeightForPStar;

            materials.forEach(m => {
                numeratorX += m.weight * m.x;
                numeratorY += m.weight * m.y;
                denominator += m.weight;
            });

            let optimalX = numeratorX / denominator;
            let optimalY = numeratorY / denominator;

            let optimalPoint = { x: optimalX, y: optimalY };


            // 2. 設置初始點和成本
            let currentOptimalPoint = optimalPoint;
            let currentLaborFactor = 1.0;
            let currentAgglomerationFactor = 1.0;
            let laborLocation = false;
            let agglomerationLocation = false;

            const pStarTotalCost = calculateFinalCost(optimalPoint, 1.0, 1.0);
            let lowestCost = pStarTotalCost;

            // 3. 考慮勞動力成本偏離
            if (laborSavings !== 'none') {
                const baseLaborSavingFactor = getLaborSavingFactor(laborSavings);
                const intensityModifier = 0.8 + (laborIntensity / 100) * 0.4;
                const adjustedLaborSavingFactor = Math.max(0.6, Math.min(0.95, baseLaborSavingFactor * intensityModifier));

                const laborZonePoint = { x: laborZone.x, y: laborZone.y };
                const laborZoneCostMixed = calculateFinalCost(laborZonePoint, adjustedLaborSavingFactor, 1.0);

                if (laborZoneCostMixed < lowestCost) {
                    currentOptimalPoint = laborZonePoint;
                    currentLaborFactor = adjustedLaborSavingFactor;
                    laborLocation = true;
                    lowestCost = laborZoneCostMixed;
                }
            }

            // 4. 考慮聚集效應偏離
            if (agglomeration !== 'none') {
                const baseAgglomSavingFactor = getAgglomerationFactor(agglomeration);
                const specModifier = 0.9 + (industrySpecialization / 100) * 0.2;
                const adjustedAgglomSavingFactor = Math.max(0.7, Math.min(0.98, baseAgglomSavingFactor * specModifier));

                const agglomZonePoint = { x: agglomerationZone.x, y: agglomerationZone.y };

                let agglomZoneLaborFactor = 1.0;
                if (laborSavings !== 'none' && isPointInCircle(agglomZonePoint, laborZone)) {
                    const baseLaborSavingFactor = getLaborSavingFactor(laborSavings);
                    const intensityModifier = 0.8 + (laborIntensity / 100) * 0.4;
                    agglomZoneLaborFactor = Math.max(0.6, Math.min(0.95, baseLaborSavingFactor * intensityModifier));
                }

                const agglomZoneTotalCost = calculateFinalCost(agglomZonePoint, agglomZoneLaborFactor, adjustedAgglomSavingFactor);

                if (agglomZoneTotalCost < lowestCost) {
                    currentOptimalPoint = agglomZonePoint;
                    currentAgglomerationFactor = adjustedAgglomSavingFactor;
                    agglomerationLocation = true;

                    currentLaborFactor = agglomZoneLaborFactor;
                    laborLocation = agglomZoneLaborFactor < 1.0;
                }
            }

            return {
                optimalPoint: currentOptimalPoint, // 返回計算出的真正的最低成本點 (P*/O)
                laborFactor: currentLaborFactor,
                agglomerationFactor: currentAgglomerationFactor,
                pStarCost: pStarTotalCost,
                pStarPoint: optimalPoint,
                lowestCost: lowestCost,
                laborLocation,
                agglomerationLocation
            };
        }

        function calculateFinalCost(location, laborFactor, agglomerationFactor) {
            const details = calculateTransportCostDetails(location);
            const transportCost = details.totalCost;

            let totalLaborCost = transportCost * laborCostWeight;
            let transportOnlyCost = transportCost * (1 - laborCostWeight);

            let costBeforeAgglomeration = transportOnlyCost + (totalLaborCost * laborFactor);

            let totalCost = costBeforeAgglomeration * agglomerationFactor;

            return totalCost;
        }


        // --- 結果渲染函數 ---

        function calculateAndRenderResults(shouldSave = true) {

            if (materials.length === 0) {
                 document.getElementById('optimal-location').innerHTML = '<p>請先新增原料產地。</p>';
                 document.getElementById('factor-comparison').innerHTML = '';
                 document.getElementById('cost-breakdown').innerHTML = '';
                 return;
            }

            setTimeout(() => {

                // 1. 自動計算真正的最低成本點 (P*/O)
                const analysis = calculateOptimalLocation();

                let displayPoint;
                let finalCost;
                let finalCostDetails;
                let finalLabel;
                let isManualTest = optimal.isManual;


                if (isManualTest) {
                    // 如果是手動模式，使用當前 optimal 的坐標作為測試點
                    displayPoint = {x: optimal.x, y: optimal.y};
                    finalCostDetails = calculateTransportCostDetails(displayPoint);
                    // 手動測試時，總成本僅顯示純運輸成本
                    finalCost = finalCostDetails.totalCost;
                    finalLabel = 'P (手動測試)';

                    // 清除勞動力/聚集分析的顯示
                    document.getElementById('labor-analysis').style.display = 'none';
                    document.getElementById('agglom-analysis').style.display = 'none';

                } else {
                    // 自動模式：將 global optimal 設置為計算出的最低成本點
                    optimal.x = analysis.optimalPoint.x;
                    optimal.y = analysis.optimalPoint.y;
                    optimal.label = (analysis.laborLocation || analysis.agglomerationLocation) ? 'O' : 'P*';

                    displayPoint = optimal;
                    finalCost = analysis.lowestCost;
                    finalCostDetails = calculateTransportCostDetails(optimal);
                    finalLabel = optimal.label;
                }

                const finalTransportCost = finalCostDetails.totalCost;
                const pStarTotalCost = calculateFinalCost(analysis.pStarPoint, 1.0, 1.0); // P* 的純運輸成本


                // --- 1. 基礎結果 (Result Box) ---
                const resultElement = document.getElementById('optimal-location');
                resultElement.innerHTML = `
                    <h4>最佳區位綜述</h4>
                    <div class="result-table">
                        <strong style="font-size: 16px;">當前測試點 (${finalLabel}):</strong> <span>(${Math.round(displayPoint.x)}, ${Math.round(displayPoint.y)})</span>
                        <strong style="font-size: 16px;">運輸成本最低點 (P*):</strong> <span>(${Math.round(analysis.pStarPoint.x)}, ${Math.round(analysis.pStarPoint.y)})</span>

                        <div class="total-row">純運輸總成本分析</div>
                        <strong>P* 運輸總成本:</strong> <span>${pStarTotalCost.toFixed(2)} 元</span>
                        <strong>當前點運輸總成本:</strong> <span style="font-weight: bold; color: ${isManualTest ? 'orange' : 'var(--primary-color)'}">
                            ${finalTransportCost.toFixed(2)} 元
                        </span>

                        ${!isManualTest ? `
                            <div class="total-row">最終最低總成本 (O/P*)</div>
                            <strong>最終總成本 (${finalLabel}):</strong> <span style="font-weight: bold; color: var(--primary-color)">${finalCost.toFixed(2)} 元</span>
                        ` : ''}

                    </div>
                `;

                // --- 2. 成本明細 (Cost Breakdown) ---

                const costBreakdown = document.getElementById('cost-breakdown');
                let materialCostHTML = '';
                let totalMaterialCost = 0;

                finalCostDetails.materialDetails.forEach(m => {
                    materialCostHTML += `<strong>原料${m.label} (${m.weight.toFixed(1)}噸):</strong> <span>${m.cost.toFixed(2)} 元</span>`;
                    totalMaterialCost += m.cost;
                });

                costBreakdown.innerHTML = `
                    <h4>運輸成本明細 (在當前區位 ${finalLabel})</h4>
                    <div class="result-table">
                        <div class="header">投入原料運輸 (總投入: ${finalCostDetails.totalInputWeight.toFixed(1)} 噸)</div>
                        ${materialCostHTML}

                        <div class="header" style="margin-top: 10px;">產出製品運輸 (市場 M)</div>
                        <strong>製品運費 (實際運重: ${finalCostDetails.actualProductWeight.toFixed(1)} 噸):</strong> <span>${finalCostDetails.productCost.toFixed(2)} 元</span>

                        <div class="total-row">總運輸成本</div>
                        <strong>總額:</strong> <span>${finalTransportCost.toFixed(2)} 元</span>
                    </div>
                `;

                // --- 3, 4, 5. 勞動力, 聚集, 總結 (僅在自動模式下執行) ---

                const factorComparison = document.getElementById('factor-comparison');

                if (isManualTest) {
                    factorComparison.innerHTML = `
                        <h4>區位決策總結</h4>
                        <p>您正在手動測試位置 P。該位置的純運輸成本為 ${finalTransportCost.toFixed(2)} 元。</p>
                        ${finalTransportCost > pStarTotalCost + 0.01 ? // 允許浮點數誤差
                            `<p style="color: #e74c3c;">✘ 當前位置 P 的運輸成本高於純運輸最低點 P* (${pStarTotalCost.toFixed(2)} 元)。</p>` :
                            `<p style="color: #2ecc71;">✓ 當前位置 P 的運輸成本已達到或接近純運輸最低點 P*。</p>`
                        }
                    `;

                } else {
                    // --- 正常模式下的詳細分析 ---

                    const transportCostBase = finalTransportCost;
                    const laborCostBase = transportCostBase * laborCostWeight;
                    const transportOnlyCostBase = transportCostBase * (1 - laborCostWeight);
                    const laborCostAtOptimal = laborCostBase * analysis.laborFactor;
                    const laborSavingAmount = laborCostBase - laborCostAtOptimal;
                    const costBeforeAgglomerationAtOptimal = transportOnlyCostBase + laborCostAtOptimal;
                    const agglomSavingAmount = costBeforeAgglomerationAtOptimal * (1 - analysis.agglomerationFactor);


                    // 勞動力分析
                    const laborAnalysis = document.getElementById('labor-analysis');
                    const laborSavingPercent = (1 - analysis.laborFactor) * 100;

                    if (laborCostWeight > 0.0 || analysis.laborFactor < 1.0) {
                        laborAnalysis.style.display = 'block';
                        laborAnalysis.querySelector('#labor-impact-detail').innerHTML = `
                            <div class="result-table">
                                <strong>勞動力成本佔總運輸的權重:</strong> <span>${(laborCostWeight * 100).toFixed(0)}%</span>
                                <strong>未修正的勞動力基礎成本:</strong> <span>${laborCostBase.toFixed(2)} 元</span>
                                <hr style="grid-column: 1 / span 2; border: 0; border-top: 1px dotted var(--border-color); margin: 3px 0;">
                                <strong>最終區位實際節省百分比:</strong> <span>${laborSavingPercent.toFixed(1) + '%'}</span>
                                <strong>勞動力成本節省金額:</strong> <span style="color: var(--labor-color); font-weight: bold;">${laborSavingAmount.toFixed(2)} 元</span>
                            </div>
                        `;
                    } else {
                        laborAnalysis.style.display = 'none';
                    }

                    // 聚集分析
                    const agglomAnalysis = document.getElementById('agglom-analysis');
                    const agglomSavingPercent = (1 - analysis.agglomerationFactor) * 100;

                    if (agglomeration !== 'none' || analysis.agglomerationFactor < 1.0) {
                        agglomAnalysis.style.display = 'block';
                        agglomAnalysis.querySelector('#agglom-impact-detail').innerHTML = `
                            <div class="result-table">
                                <strong>聚集經濟基礎潛力:</strong> <span>${(1 - getAgglomerationFactor(agglomeration)) * 100}%</span>
                                <strong>產業專業化程度:</strong> <span>${industrySpecialization}%</span>
                                <hr style="grid-column: 1 / span 2; border: 0; border-top: 1px dotted var(--border-color); margin: 3px 0;">
                                <strong>最終間接成本節省係數:</strong> <span>${agglomSavingPercent.toFixed(1) + '%'}</span>
                                <strong>聚集經濟節省金額:</strong> <span style="color: var(--agglom-color); font-weight: bold;">${agglomSavingAmount.toFixed(2)} 元</span>
                            </div>
                        `;
                    } else {
                        agglomAnalysis.style.display = 'none';
                    }

                    // 總結
                    let comparisonHTML = `<h4>區位決策總結</h4>`;

                    if (analysis.laborLocation || analysis.agglomerationLocation) {
                        comparisonHTML += `<p>最佳區位 (${optimal.label}) 偏離了純粹的運輸成本最低點 (P*)。</p>`;

                        if (analysis.laborLocation) {
                            comparisonHTML += `<p style="color: var(--labor-color); margin-bottom: 5px;">✓ <strong>勞動力因素：</strong> 勞動力成本節省（${laborSavingAmount.toFixed(2)}元）足以抵消增加的運輸成本，導致區位偏離。</p>`;
                        }
                        if (analysis.agglomerationLocation) {
                            comparisonHTML += `<p style="color: var(--agglom-color); margin-bottom: 5px;">✓ <strong>聚集因素：</strong> 聚集經濟節省（${agglomSavingAmount.toFixed(2)}元）導致區位遷移到聚集區以最小化總成本。</p>`;
                        }

                    } else {
                        comparisonHTML += `<p>在此情境下，<strong>運輸成本</strong>是唯一決定區位的因素。</p>`;
                        comparisonHTML += `<p>勞動力或集聚效應不足以抵消額外運輸成本，因此區位位於純運輸最低點 P*。</p>`;
                    }
                    factorComparison.innerHTML = comparisonHTML;
                } // End of else (Auto Mode)


                // 4. 更新地圖和歷史記錄
                drawCanvas();

                if (shouldSave && !optimal.isManual) {
                    // 僅在非手動模式下保存歷史記錄
                    saveCurrentState();
                }

            }, 50);
        }


        // --- 綁定事件和初始化 ---

        function setupControlTabs() {
            const transportBtn = document.getElementById('tab-transport-btn');
            const deviationBtn = document.getElementById('tab-deviation-btn');
            const transportControls = document.getElementById('transport-controls');
            const deviationControls = document.getElementById('deviation-controls');

            transportBtn.addEventListener('click', () => {
                transportBtn.classList.add('active');
                deviationBtn.classList.remove('active');
                transportControls.style.display = 'block';
                deviationControls.style.display = 'none';
            });

            deviationBtn.addEventListener('click', () => {
                deviationBtn.classList.add('active');
                transportBtn.classList.remove('active');
                deviationControls.style.display = 'block';
                transportControls.style.display = 'none';
            });
        }

        // 初始化點位和Canvas
        function initializeApp() {
            const container = document.getElementById('canvas-container');

            // 由於 Canvas 寬高可能會在 resize 中調整，這裡只需要初始化點位

            materials = [
                { id: generateUniqueId('M'), x: 150, y: 50, weight: 3, color: '#e74c3c', label: 'A' },
                { id: generateUniqueId('M'), x: 450, y: 50, weight: 2, color: '#2ecc71', label: 'B' }
            ];
            // 保持 market 點的初始重量
            market = { x: 275, y: 250, label: '市場(M)', color: '#3498db', weight: 3.5 };
            optimal = { x: 0, y: 0, label: 'O', color: '#9b59b6', isManual: false };

            // 重置參數的 UI
            // 移除 weightLoss
            transportCost = 5; laborCostWeight = 0.3; laborSavings = 'none';
            laborIntensity = 50; agglomeration = 'none'; industrySpecialization = 50;

            initResizers();
            setupControlTabs();
            updateUIFromState();

            // 確保 canvas 尺寸在首次加載時正確設置
            if (window.innerWidth > 900) {
                // 在寬屏模式下，canvas 應適應其父容器的高度
                const mapSection = document.getElementById('map-section');
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            } else {
                // 窄屏模式下保持寬高比
                canvas.width = container.offsetWidth;
                canvas.height = (container.offsetWidth / 550) * 400;
            }

            autoCalculateAndStore();
        }

        window.onload = initializeApp;


        // --- UI 事件綁定 (修復卡頓問題) ---

        document.getElementById('add-material-btn').addEventListener('click', function() {
            addMaterial();
        });

        document.getElementById('find-optimal-btn').addEventListener('click', function() {
            // 執行一次完整的自動計算
            const analysis = calculateOptimalLocation();

            // 確保 optimal 點是計算出來的 P*/O 點
            optimal.x = analysis.optimalPoint.x;
            optimal.y = analysis.optimalPoint.y;
            optimal.label = (analysis.laborLocation || analysis.agglomerationLocation) ? 'O' : 'P*';
            optimal.isManual = false; // 確保退出手動模式

            calculateAndRenderResults(true);
        });


        const controlElements = [
            'transport-cost', 'labor-cost-weight',
            'labor-savings', 'labor-intensity', 'agglomeration', 'industry-specialization'
        ];

        // 專門為 market-weight 綁定事件
        const marketWeightElement = document.getElementById('market-weight');
        if (marketWeightElement) {
            marketWeightElement.addEventListener('input', function(e) {
                market.weight = parseFloat(e.target.value);
                document.getElementById('market-weight-value').textContent = market.weight.toFixed(1) + ' 噸';
                debouncedCalculateAndStore();
            });
        }


        controlElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                const handler = function(e) {
                    const value = e.target.value;

                    document.getElementById(`${id}-value`) && (document.getElementById(`${id}-value`).textContent = id.includes('intensity') || id.includes('specialization') ? `${value}%` : (id === 'labor-cost-weight' || id === 'transport-cost' ? parseFloat(value).toFixed(1) : value));

                    if (id === 'labor-savings') {
                        document.getElementById('labor-intensity-container').style.display = value === 'none' ? 'none' : 'block';
                    }
                    if (id === 'agglomeration') {
                        document.getElementById('specialization-container').style.display = value === 'none' ? 'none' : 'block';
                    }

                    // 使用去抖函數進行計算
                    debouncedCalculateAndStore();
                };

                element.addEventListener('input', handler);
                if (element.tagName === 'SELECT') {
                    element.addEventListener('change', handler);
                }
            }
        });


        STEP_BACK_BTN.addEventListener('click', restorePreviousState);
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                restorePreviousState();
            }
        });

        document.getElementById('reset-btn').addEventListener('click', function() {
            historyStack = [];
            initializeApp();
        });

        document.getElementById('show-theory-btn').addEventListener('click', function() {
            const theoryExplanation = document.getElementById('theory-explanation');
            if (theoryExplanation.style.display === 'none') {
                theoryExplanation.style.display = 'block';
                this.textContent = '隱藏韋伯理論說明';
            } else {
                theoryExplanation.style.display = 'none';
                this.textContent = '顯示韋伯理論說明';
            }
        });

        document.getElementById('toggle-debug').addEventListener('click', function() {
            debugMode = !debugMode;
            const debugInfo = document.getElementById('debug-info');
            if (debugMode) {
                debugInfo.style.display = 'block';
                this.textContent = '隱藏調試信息';
            } else {
                debugInfo.style.display = 'none';
                this.textContent = '顯示調試信息';
            }
        });

        // --- 畫布拖曳邏輯 ---

        function findPointAt(x, y) {
            // 檢查 Optimal 點 (P*/O)
            const distOptimal = distance({x, y}, optimal);
            if (optimal.x !== 0 && optimal.y !== 0 && distOptimal < 15) return { type: 'optimal', point: optimal };

            // 檢查市場點
            const distM = distance({x, y}, market);
            if (distM < 15) return { type: 'market', point: market };

            // 檢查原料點
            for (const m of materials) {
                const dist = distance({x, y}, m);
                if (dist < 15) return { type: 'material', point: m };
            }

            // 檢查勞動力區中心
            if (laborSavings !== 'none') {
                const distLabor = distance({x, y}, laborZone);
                if (distLabor < 15) return { type: 'laborZone', point: laborZone };
            }

            // 檢查聚集區中心
            if (agglomeration !== 'none') {
                const distAgglom = distance({x, y}, agglomerationZone);
                if (distAgglom < 15) return { type: 'agglomerationZone', point: agglomerationZone };
            }

            return null;
        }

        let dragTimeout;

        function handleDragStart(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const clicked = findPointAt(x, y);
            if (clicked) {
                isDragging = true;
                selectedPoint = clicked;
                if (dragTimeout) clearTimeout(dragTimeout);

                // 如果拖曳的是 optimal 點，切換到手動模式
                if (selectedPoint.type === 'optimal') {
                    optimal.isManual = true;
                    // 清除滑塊的 debounceTimer，確保手動拖曳時不被滑塊操作干擾
                    clearTimeout(debounceTimer);
                    optimal.label = 'P'; // 設置臨時標籤
                }
            }
        }

        function handleDragMove(clientX, clientY) {
            if (isDragging && selectedPoint) {
                const rect = canvas.getBoundingClientRect();
                const newX = clientX - rect.left;
                const newY = clientY - rect.top;

                const clampedX = Math.max(20, Math.min(canvas.width - 20, newX));
                const clampedY = Math.max(20, Math.min(canvas.height - 20, newY));

                const snappedPoint = snapToGrid(clampedX, clampedY);

                selectedPoint.point.x = snappedPoint.x;
                selectedPoint.point.y = snappedPoint.y;

                drawCanvas();

                // 如果正在手動拖曳 optimal 點，則實時更新結果 (使用 runCalculationAndStore)
                if (selectedPoint.type === 'optimal' && optimal.isManual) {
                    if (dragTimeout) clearTimeout(dragTimeout);
                    dragTimeout = setTimeout(() => {
                        calculateAndRenderResults(false); // 不保存歷史記錄
                    }, 50); // 50ms 節流
                } else {
                    // 其他點位的拖曳仍使用標準的 runCalculationAndStore (會保存歷史記錄)
                    if (dragTimeout) clearTimeout(dragTimeout);
                    dragTimeout = setTimeout(runCalculationAndStore, 150);
                }
            }
        }

        function handleDragEnd() {
            if (isDragging) {
                if (selectedPoint && selectedPoint.type === 'optimal' && optimal.isManual) {
                    // 手動拖曳 optimal 點結束後，將其設置為非手動，並強制執行一次完整的自動計算，讓它跳回 P*/O
                    optimal.isManual = false;

                    // 執行自動計算並保存歷史
                    runCalculationAndStore();
                } else {
                    // 其他點位的拖曳結束
                    runCalculationAndStore();
                }

                isDragging = false;
                selectedPoint = null;
                if (dragTimeout) clearTimeout(dragTimeout);
            }
        }

        // Mouse Events
        canvas.addEventListener('mousedown', function(e) {
            handleDragStart(e.clientX, e.clientY);
        });
        canvas.addEventListener('mousemove', function(e) {
            handleDragMove(e.clientX, e.clientY);
        });
        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd); // 確保在移出畫布時停止拖曳

        // Touch Events (修復 iPad 拖曳問題)
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            handleDragStart(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                handleDragMove(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchend', handleDragEnd);

        window.addEventListener('resize', function() {
            const container = document.getElementById('canvas-container');
            if (window.innerWidth > 900) {
                // 寬屏/桌面模式：由 Resizer/容器寬度控制
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            } else {
                // 窄屏/移動模式：固定比例
                canvas.width = container.offsetWidth;
                canvas.height = (container.offsetWidth / 550) * 400;
            }
            drawCanvas();
            calculateAndRenderResults(false);
        });

        function snapToGrid(x, y) {
            const SNAP_THRESHOLD = 15;
            const gridX = Math.round(x / GRID_SIZE) * GRID_SIZE;
            const gridY = Math.round(y / GRID_SIZE) * GRID_SIZE;
            const distToGrid = Math.sqrt(Math.pow(x - gridX, 2) + Math.pow(y - gridY, 2));

            if (distToGrid < SNAP_THRESHOLD) {
                return { x: gridX, y: gridY };
            }
            return { x: x, y: y };
        }

        function initResizers() {
            const mapControlResizer = document.getElementById('map-control-resizer');
            const mapSection = document.getElementById('map-section');
            const canvasContainer = document.getElementById('canvas-container');
            const mainContainer = document.getElementById('main-container');

            let isHorizontalResizing = false;
            let startY, startMapHeight;
            let isVerticalResizing = false;
            let startX, startLeftWidth;

            // 垂直 Resizer 邏輯
            document.getElementById('column-resizer').addEventListener('mousedown', function(e) {
                if (window.innerWidth < 900) return;
                isVerticalResizing = true;
                startX = e.clientX;
                startLeftWidth = document.getElementById('left-column').offsetWidth;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'ew-resize';
            });

            // 水平 Resizer 邏輯
            mapControlResizer.addEventListener('mousedown', function(e) {
                if (window.innerWidth < 900) return;
                // 由於我們固定了高度，這裡不啟動 Resizer 邏輯
            });

            document.addEventListener('mousemove', function(e) {
                if (isHorizontalResizing) {
                    e.preventDefault();
                    // 固定高度，無操作
                }

                if (isVerticalResizing) {
                    e.preventDefault();
                    const deltaX = e.clientX - startX;
                    const containerWidth = mainContainer.offsetWidth;
                    const newLeftWidth = Math.max(300, Math.min(startLeftWidth + deltaX, containerWidth - 300));
                    const leftPercentage = (newLeftWidth / containerWidth) * 100;

                    mainContainer.style.gridTemplateColumns = `${leftPercentage}% auto`;

                    // 調整 canvas 寬度
                    canvas.width = canvasContainer.offsetWidth;
                    drawCanvas();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isHorizontalResizing || isVerticalResizing) {
                    isHorizontalResizing = false;
                    isVerticalResizing = false;
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                    window.dispatchEvent(new Event('resize'));
                }
            });

            mapControlResizer.addEventListener('touchstart', (e) => {
                if (window.innerWidth > 900) {
                   // 固定高度，無操作
                }
            });
            document.getElementById('column-resizer').addEventListener('touchstart', (e) => {
                if (window.innerWidth > 900) {
                    isVerticalResizing = true;
                    startX = e.touches[0].clientX;
                    startLeftWidth = document.getElementById('left-column').offsetWidth;
                    e.preventDefault();
                }
            });
            document.addEventListener('touchend', function() {
                if (isHorizontalResizing || isVerticalResizing) {
                    isHorizontalResizing = false;
                    isVerticalResizing = false;
                }
            });
        }

    </script>
</body>
</html>
